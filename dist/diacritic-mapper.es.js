function e(e){return"string"==typeof e}class t{get(t,r,i){return e(r)&&1===r.length?this.diacriticTrap(t,r):Reflect.get(t,r,i)}diacriticTrap(e,t){}}class r extends t{diacriticTrap(t,r){return Object.keys(t.matcher).find(i=>e(t.matcher[i])&&t.matcher[i].includes(r))||r}}class i extends t{diacriticTrap(e,t){return[t.toLowerCase(),t.toUpperCase()].map(t=>e.matcher[t]||"").join("")||t}}class s extends t{diacriticTrap(e,t){return new RegExp(`[${t}${e.matcher[t]||""}]`,"u")}}class c extends t{diacriticTrap(e,t){return new RegExp(`[${t}${e.insensitiveMatcher[t]||""}]`,"ui")}}class n{constructor(e){const t=e.reduce((e,t)=>(Object.entries(t).forEach(([t,r])=>{if(t in e){const i=r.split("").filter(r=>!e[t].includes(r)).join("");e[t]+=i}else e[t]=r}),e),{});this.matcher=Object.freeze(t),this.insensitiveMatcher=new Proxy(this,new i),this.validator=new Proxy(this,new s),this.insensitiveValidator=new Proxy(this,new c)}matcherBy(e){return Object.keys(this.matcher).filter(t=>e.test(t)).map(e=>this.matcher[e]||"").join("")}}const a=(...e)=>new Proxy(new n(e),new r);export{a as DiacriticMapper};
